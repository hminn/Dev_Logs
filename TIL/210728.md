# 2021년 07월 28일 (수) 

## 오늘 학습한 내용

### > Algorithm 스터디

- 온라인 스터디 진행 : 코드 리뷰 및 피드백
- 알고리즘 문제풀이
  - 숫자판 점프 : DFS + 브루트 포스 기본 문제
  - 내리막 길 : DFS + DP or BFS + PriorityQueue  
    => DFS + DP 방식으로 푸는 방법이 확실하게 이해가 가지 않았다.  
    => 재귀 돌면서 메모이제이션 하는 로직 구조가 아직 낯설어서 그런 것 같다.  
    => 비슷한 유형의 문제를 풀게 된다면 DFS + DP 방식으로 풀어보도록 하자.

### > NodeJS : 웹 API 서버 만들기

- **호출 서버 만들기**  
  => JWT 발급 및 검증하는 과정은 모든 API 요청에 필요하므로, JWT 발급 및 검증 과정과 API 요청 처리하는 request 함수를 만들어 라우팅하는 패턴을 기억하자.  
  => 서버에서 서버로 API 요청 시에, 요청 헤더의 origin에 요청을 보내는 쪽의 도메인 값을 넣어줘야 하는 것을 잊지 말자! (브라우저에서 서버로 요청 시에는 브라우저가 헤더에 origin 값을 넣어준다)  
  => 요청을 주고 받을 때, 인코딩-디코딩 하는 패턴. 언제, 어떤 이유로 하는지 확실하게 알아두자.  
  
- **SNS API 서버 만들기**  

- **API 사용량 제한 구현하기** : express-rate-limit 패키지  
  => apiLimiter 미들웨어 작성하는 패턴과 라우터에 미들웨어 장착하는 방식과 주의할 점 체크.  
  => 이전 버전의 API 요청에 대해 경고 메세지를 날리는 deprecated 미들웨어 작성 패턴  
  => 클라이언트 응답 코드는 하나의 문서로 정리해서 프론트 팀 혹은 API 사용자들이 참고할 수 있도록!  
  => API 사용량은 서버가 재시작되면 사용량이 초기화 되므로 실제 서비스에서는 사용량을 저장할 DB를 따로 마련하는 것이 좋다.

- **CORS 이해하기**  
  => CORS란 무엇인가?  
  : Cross-Origin Resource Sharing, 서로 다른 출처 간의 리소스 공유에 대한 정책.  
  : 보통 브라우저에서 서버로 요청을 보낼 때, 도메인이 다른 경우 CORS 에러가 발생한다.  
  : 오픈된 공간인 웹에서 다른 출처 간에 리소스를 공유하는 일은 굉장히 흔하지만, 아무런 제약없이 모든 경우를 허용한다면 악의를 가진 사용자가 공격하기에 매우 쉬운 환경이 되어버린다. 이에 대한 제약을 두기 위해 기본적으로 같은 출처에서만 리소스를 공유하도록 하되, 몇가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하는 규칙을 가진 정책을 CORS 라고 한다.   
  => CORS 에러 처리 하는 방식  

  1. res.setHeader를 이용하여 Access-Control-Allow-Origin에 요청 도메인 값을 넣어준다.
  2. cors 패키지를 이용하여 필요한 응답 헤더를 넣어주는 미들웨어를 사용한다.
  3. 브라우저와 API 서버 사이에 프록시 서버를 두고, 브라우저에서 프록시 서버로 요청을 보내고 다시 그 요청을 프록시 서버에서 API 서버로 요청을 보내는 방식 (프록시 서버와 브라우저의 도메인은 같아야 함)  
     => http-proxy-middleware 패키지 활용  

  => 미들웨어 확장 패턴 기억하기 (미들웨어가 특정 상황에만 동작하도록 커스터마이징 하는 패턴)



## Feedback

- 한동안 피곤하다는 이유로 TIL 작성을 미뤘더니 하루가 정리되지 않는 느낌이다.
- 최대한 23시 이전에 할 일 다 끝내고 30분 정도 시간 내서 TIL 작성해보도록 하자.
- 매칭42를 능동적으로 진행하다보니 지루했던 프로젝트에 다시 흥미가 생긴다.
- 코딩이 재밌을 때는 내가 열심히 몰입하고 있을 때임을 잊지 말자!
- 재미없어서 하기 싫은게 아니라 열심히 하지 않고 있기 때문에 재미가 없는 것.
- 최대한 몰입하고 즐기도록 하자





